---
title: "Advanced Plotting in R"
output:
  html_document: default
urlcolor: blue
---

```{r setup, include=FALSE, warning=FALSE, message=FALSE}

knitr::opts_chunk$set(echo = TRUE)

############################################################
##### We suggest using library(tidyverse)! #################
##### By loading in tidyverse, many useful packages will ###
##### automatically load including ggplot2, dplyr, & tidyr.#
############################################################

library(tidyverse)

midus_orig <- read_csv("https://raw.githubusercontent.com/kijohnson/ADA_Spring_2020/master/Class%204/midus.csv")

midus <- na.omit(midus_orig) # use complete cases only for now
```
## Plotting in `ggplot2` -- Review of Core Concepts

#### Basic Plots

Remember Shrek? 

<center>
> *"Layers. Onions have layers. Ogres have layers. Onions have layers. You get it? We both have layers."*
</center>

`ggplot(things that impact entire plot) +` </br>
\ \ `geom_something(things that impact just the something)`


```{r basic, out.width=c('50%', '50%'), fig.show='hold'}
# ggplot(things that impact entire plot) == LAYER 1!
ggplot(data = midus, aes(x = BMI, y = self_esteem))

# geom_something(things that impact just the something) == LAYER 2
# Let's make a Scatter Plot
ggplot(data = midus, aes(x = BMI, y = self_esteem)) +
  geom_point()

# In order to change the names of the axes and add a title, 
# you'll want to add a new LAYER!
ggplot(data = midus, aes(x = BMI, y = self_esteem)) +
  geom_point() +
  labs(x = "Body Mass Index (BMI)",
       y = "Self-Esteem",
       title = "Scatterplot of BMI by Self-Esteem")

```

#### Remove `NA` from within a plot
This requires truly missing values to be coded as `NA` and *not* something like `999` or `.` or `"na"`. 
```{r navals, out.width=c('50%', '50%'), fig.show='hold'}

# What happens when you don't remove the `NA` values?
ggplot(data = midus_orig, aes(x = BMI, y = self_esteem)) +
  geom_point() +
  labs(x = "Body Mass Index (BMI)",
       y = "Self-Esteem",
       title = "Scatterplot of BMI by Self-Esteem")

# Actually remove them
ggplot(data = midus, aes(x = BMI, y = self_esteem)) +
  geom_point(na.rm = TRUE) +
  labs(x = "Body Mass Index (BMI)",
       y = "Self-Esteem",
       title = "Scatterplot of BMI by Self-Esteem")

```

#### Exercise 1: Layers
The code below is broken. What is missing? *HINT: run the broken code, and look at the error message!*

```{r exercise1, eval=FALSE}
ggplot(data = midus, aes(x = sex, y = BMI))
  geom_violin() +
  labs(x = "Sex", y = "Body Mass Index (BMI)",
       title = "Exercise 1")
```

#### Changing Aesthetics
Compare the code for the following 2 plots, and notice the differences. What happens to the shape and color of the points? What happens to the size of the plot? Why?

```{r aes, out.width=c('50%', '50%'), fig.show='hold'}

ggplot(data = midus, aes(x = life_satisfaction, y = self_esteem)) +
  geom_point(color = "purple", shape = 3) +
  labs(x = "Life Satisfaction",
       y = "Self-Esteem",
       title = "Changing Aesthetics",
       subtitle = "Plot 1")

ggplot(data = midus, aes(x = life_satisfaction, y = self_esteem)) +
  geom_point(aes(color = sex, shape = sex)) +
  labs(x = "Life Satisfaction",
       y = "Self-Esteem",
       title = "Changing Aesthetics",
       subtitle = "Plot 2")

```

```{r aes2}
############################################################
##### What should you do when you have overlapping points? #
##### The 'alpha' parameter controls transparency. #########
##### Notice how it's inside geom_point, but outside aes! ##
##### To make this easier to read, lets make the SIZE of ###
##### all points bigger. Notice how it's also outside aes! #
############################################################

ggplot(data = midus, aes(x = life_satisfaction, y = self_esteem)) +
  geom_point(aes(color = sex, shape = sex), alpha = .6, size = 4) +
  labs(x = "Life Satisfaction",
       y = "Self-Esteem",
       title = "Changing Aesthetics",
       subtitle = "Plot 3")

## We will talk more about overlapping points below with "jittering".
```

##### Bubble Plot 
A bubble plot is a lot like a scatter plot, with an extra size dimension (See [here](https://en.wikipedia.org/wiki/Bubble_chart) for more). In `ggplot2`, it's easy to make! All you have to do is put the `size` argument inside of `aes()`. 

```{r bubbleplots}

ggplot(data = midus, aes(x = self_esteem, y = life_satisfaction)) +
  geom_point(alpha = .5, aes(size = hostility)) +
  labs(x = "Self-Esteem", y = "Life Satisfaction", title = "Bubble Plot")

```

#### Re-organizing Factors

```{r levels}
# geom_bar uses count as default for the y-axis.
# This gives you the same information as the table() function

table(midus$heart_self)

ggplot(data = midus, aes(x = heart_self)) +
  geom_bar(aes(fill = heart_self))

############################################################
##### Look at the levels of your factor to see what ########
##### order things are in. Unless you tell R, it's going ###
##### to be ordered alphabetically. If you want a different#
##### order, you must re-order your factor variable, and ###
##### then plot. If you're unsure, use levels() function. ##
############################################################

# look at levels
levels(midus$heart_self)

# make a new variable for the new order of levels, then 
# assign that new order
new_heart_self <- c("Yes", "No")
midus$heart_self <- factor(midus$heart_self, levels = new_heart_self)
  
ggplot(data = midus, aes(x = heart_self)) +
  geom_bar(aes(fill = heart_self))

# change things back using nested functions
midus$heart_self <- factor(midus$heart_self, levels = c("No","Yes"))

levels(midus$heart_self)
```

## Color Palettes
These are useful when you have a TON of data and want to maximize differences between colors (or you want to use colors that are colorblind friendly). Or maybe you just don't like the default colors. 

If you already know the name of the color palette you want to use,
then you do not need to load any additional packages. If you want to play around, load the `RColorBrewer` package.
```{r palette}
library(RColorBrewer)

# Find the Palette that you like. Look up help page for
# display.brewer.all() to learn more about the different types
display.brewer.all()

# Rather than manually set each of the colors, we can add a new LAYER

ggplot(data = midus, aes(x = self_esteem, y = life_satisfaction)) + # Layer 1
  geom_point(aes(color = heart_self, shape = heart_self)) + # Layer 2
  labs(x = "Self-Esteem", y = "Life Satisfaction", # Layer 3
       title = "Color Palettes") +
  scale_color_brewer(palette = "Pastel1") # Layer 4

# Let's see this when we have more than 2 levels
# Need to first create the levels -- using code from Day 3

midus$age_category <- cut(x = midus$age,
                          breaks = c(28, 40, 60, 84),
                          labels=c("young", "middle", "old"),
                          include.lowest = TRUE)

ggplot(data = midus, aes(x = self_esteem, y = life_satisfaction)) + # Layer 1
  geom_point(aes(color = age_category, shape = age_category)) + # Layer 2
  labs(x = "Self-Esteem", y = "Life Satisfaction", # Layer 3
       title = "Color Palettes",
       subtitle = "With More Factor Levels") +
  scale_color_brewer(palette = "Pastel1") # Layer 4
```

There are TONS of color palettes. Some are great, some are kinda ridiculous. For example, there are Wes Anderson themed palettes! To view them, click [here](https://github.com/karthik/wesanderson#wes-anderson-palettes).

## Themes
Themes are great when you want to change the entire look of your plot. Most of the themes you need are built into the main `ggplot2` package. If you want more options, check out the `ggthemes` package and there are also some other individual packages (some favorites include FiveThirtyEight and XKCD themes!). Here are some of the more basic themes:

```{r theme1, out.width=c('50%', '50%'), fig.show='hold'}
# No specified theme -- the ggplot2 default
ggplot(data = midus, aes(x = heart_father, y = life_satisfaction)) +
  geom_violin(aes(fill = heart_father)) + 
  labs(x = "Dad Heart Attack?", y = "Life Satisfaction",
       title = "No Set Theme")

# Black and White
ggplot(data = midus, aes(x = heart_father, y = life_satisfaction)) +
  geom_violin(aes(fill = heart_father)) + 
  labs(x = "Dad Heart Attack", y = "Life Satisfaction",
       title = "Black and White Theme") +
  theme_bw()

# Black and White, but now the baseline font size is smaller
ggplot(data = midus, aes(x = heart_father, y = life_satisfaction)) +
  geom_violin(aes(fill = heart_father)) + 
  labs(x = "Dad Heart Attack", y = "Life Satisfaction",
       title = "Black and White Theme",
       subtitle = "different base size") +
  theme_bw(base_size = 7)

# Classic theme -- no background gridlines
ggplot(data = midus, aes(x = heart_father, y = life_satisfaction)) +
  geom_violin(aes(fill = heart_father)) + 
  labs(x = "Dad Heart Attack", y = "Life Satisfaction",
       title = "Classic Theme") +
  theme_classic()

# Dark theme
ggplot(data = midus, aes(x = heart_father, y = life_satisfaction)) +
  geom_violin(aes(fill = heart_father)) + 
  labs(x = "Dad Heart Attack", y = "Life Satisfaction",
       title = "Dark Theme") +
  theme_dark()

# Void Theme
ggplot(data = midus, aes(x = heart_father, y = life_satisfaction)) +
  geom_violin(aes(fill = heart_father)) + 
  labs(x = "Dad Heart Attack", y = "Life Satisfaction",
       title = "Void Theme") +
  theme_void()

```

#### Exercise 2: Color Palettes & Themes
Go through the following:

1. Look up the help documentation for the `display.brewer.all()` function.
    - Use this function to find a color palette that is good for 3 colors
    - Include the argument `type = "qual"`
    - Use the function's arguments to make this palette colorblind friendly.
    - Pick whichever of these you like, and use it in the following code.
2. Change the overall theme to be more minimalist. 
3. You might find that some of the categories overlap. Make an adjustment so you can more clearly see each distribution. 

```{r exercise2}
display.brewer.all(n = 3, type = "qual", colorblindFriendly = T)
# use "Paired"

ggplot(data = midus, aes(x = hostility)) +
 geom_density(aes(fill = age_category), alpha = .4) +
 labs(x = "Hostility",
      title = "Exercise 2") +
  scale_fill_brewer(palette = "Paired") +
  theme_classic()

```

## Themes Continued...

What if you like a theme, but you still want to make changes? For example, let's say you like the black and white theme, but you still want to: 

- get rid of minor grid lines
- remove the title of your legend
- center the title and subtitle
- make a black box around your legend, and fill it with the color gray

You first define your theme, then add another **theme()** layer that includes arguments with your specific changes. You pick an argument to change, set it equal to one of the following 4 options, and finally put your change inside of one of these 4 options. You can think of them as "wrappers":

1. `element_text()`
2. `element_rect()`
3. `element_line()`
4. `element_blank()`

Using this gives you an overwhelming amount of flexibility! _**This is where Google is your friend!**_

```{r theme2, message=FALSE, out.width=c('50%', '50%'), fig.show='hold'}
# Black and white theme without changes
ggplot(data = midus, aes(x = heart_father, y = life_satisfaction)) +
  geom_violin(aes(fill = heart_father)) + 
  labs(x = "Dad Heart Attack", y = "Life Satisfaction",
       title = "Black and White Theme") +
  theme_bw()

# Black and white theme with changes
ggplot(data = midus, aes(x = heart_father, y = life_satisfaction)) +
  geom_violin(aes(fill = heart_father)) + 
  labs(x = "Dad Heart Attack", y = "Life Satisfaction",
       title = "Black and White Theme") +
  theme_bw() +
  theme(panel.grid.major =  element_line(color = NA),
        legend.title = element_blank(),
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5),
        legend.background = element_rect(color = "black",
                                         fill = "gray"))

```

## Manually Changing Things
There are _**many**_ ways to change something within `ggplot2`. Below is just a selection of those frequently used. To find exact values, use Google!

```{r manual}
# Shapes
ggplot(data = midus, aes(x = self_esteem, y = life_satisfaction)) +
  geom_point(aes(color = age_category, shape = age_category)) +
  labs(x = "Self-Esteem", y = "Life Satisfaction",
       title = "Manually Setting Shapes") +
  scale_shape_manual(values = c(9,10,11))

# Make all colors various shades of GREY for black/white printing
ggplot(data = midus, aes(x = self_esteem, y = life_satisfaction)) +
  geom_boxplot(aes(fill = age_category)) +
  labs(x = "Self-Esteem", y = "Life Satisfaction",
       title = "All Grey") +
  scale_fill_grey(start = 0, end = 0.8, 
                  labels = c("young", "middle", "old"))

# Changing the legend: location, title, and labels
# ONlY change the title
ggplot(data = midus, aes(x = self_esteem, y = life_satisfaction)) +
  geom_point(aes(color = age_category, shape = age_category), alpha = .5) +
  labs(x = "Self-Esteem", y = "Life Satisfaction",
       title = "Legend Change",
       color = "Age (by group)",
       shape = "Age (by group)")

# Change the title, location, and labels at once
ggplot(data = midus, aes(x = self_esteem, y = life_satisfaction)) +
  geom_point(aes(color = age_category, shape = age_category), alpha = .5)+
  labs(x = "Self-Esteem", y = "Life Satisfaction",
       title = "Legend Change Part 2") +
  scale_color_discrete(name = "Age (by group)",
                       labels = c("YOUNG", "MID", "OLD")) +
  scale_shape(guide = FALSE) + #removes the legend for shapes
  theme(legend.position = "bottom")
```

```{r out.width=c('50%', '50%'), fig.show='hold'}

# Change the scale of the x-axis
## Original plot
ggplot(data = midus, aes(x = self_esteem)) +
  geom_density(aes(fill = heart_self), alpha = .5) +
  labs(x = "Self-Esteem", y = "Density", title = "Coord Change",
       subtitle = "Default") +
  theme_classic()

## With modified x-axis
ggplot(data = midus, aes(x = self_esteem)) +
  geom_density(aes(fill = heart_self), alpha = .5) +
  labs(x = "Self-Esteem", y = "Density", title = "Coord Change",
       subtitle = "Default") +
  theme_classic() +
  xlim(c(0,75))

```

```{r out.width=c('50%', '50%'), fig.show='hold'}
# Change the angle of text on an axis - ONLY ANGLE CHANGE
ggplot(data = midus, aes(x = age_category)) +
  geom_bar(aes(fill = age_category)) +
  labs(subtitle = "only changing the angle") +
  theme_light() +
  theme(axis.text.x = element_text(angle = 90))

# Change the angle of text on an axis - ANGLE & VERTICAL ALIGNMENT
ggplot(data = midus, aes(x = age_category)) +
  geom_bar(aes(fill = age_category)) +
  labs(subtitle = "changing the angle and vertical alignment") +
  theme_light() +
  theme(axis.text.x = element_text(angle = 90, vjust = .5))

# Change the angle of text on an axis - ANGLE & VERTICAL ALIGNMENT
# & HORIZONTAL ALIGNMENT
ggplot(data = midus, aes(x = age_category)) +
  geom_bar(aes(fill = age_category)) +
  labs(subtitle ="angle, vertical,\nand horizontal aligntment") +
  theme_light() +
  theme(axis.text.x = element_text(angle = 90, vjust = .5,
                                   hjust = 1))

# What about different angles? 
ggplot(data = midus, aes(x = age_category)) +
  geom_bar(aes(fill = age_category)) +
  labs(subtitle ="45 degree angle") +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1,
                                   hjust = 1))
```

#### Exercise 3: Ugliest Plot in the World
The code below makes THE ugliest plot ever. Your job is to work backwards and turn this into a plot that is publication-ready (and not super ugly). Do so *without* deleting any whole layers. Just modify the existing code. 

```{r exercise 3}

ggplot(data = midus, aes(x = life_satisfaction, y = self_esteem)) +
  geom_point(aes(shape = age_category, color = age_category),
             size = 3, alpha = .5) +
  scale_shape_manual(values = c(16,17,18)) +
  scale_color_brewer(palette = "Dark2") +
  theme_classic() +
  theme(axis.text.x = element_text(color = "black",
                                   face = "bold",
                                   angle = 0),
        axis.text.y = element_text(color = "black",
                                   #family = "Times",
                                   face = "bold",
                                   angle = 0),
        axis.title = element_text(face = "italic",
                                  #family = "Times",
                                  size = 10),
        plot.background = element_rect(fill = "white"),
        legend.position = "top")
```

## Faceting
Faceting lets you break up your plot into multiple sub-plots. There are two types: `facet_grid` and `facet_wrap`. Within each, read the **~** as "by". 

#### `facet_grid`
Especially great when you have multiple factors to separate on. If you want to change the x- and y-axes so that they best fit the data (rather than keep them the exact same across subplots), use the `scales` argument (see Plot 2 below).

Like the name implies, `facet_grid` is going to make a grid. Just like a matrix, the right hand side is rows and the left hand side is columns (i.e., 2x3 matrix = 2 rows and 3 columns). You can put your factor on either side, but that will change the layout of your grid! For example:

* `~ age_category` is read as "by age category", and is in the column position. The result is a 1x3 grid. There are 3 columns because `age_category` has 3 levels.
* `age_category ~` is read as "age category by". This doesn't work! You need something else. To indicate that you do not want to facet by any additional factor, use the `.`. So the correct syntax for faceting `age_category` in the row position is `age_category ~ .`. The result will be a 3x1 grid. 

```{r fgrid1}
# Plot 1 = 1 variable to separate on, keep the axes the same 
# for each sub-plot
ggplot(data = midus, aes(x = BMI, y = life_satisfaction)) +
  geom_point(aes(color = age_category, shape = age_category)) + 
  labs(x = "Body Mass Index (BMI)", y = "Life Satisfaction",
       title = "Facet_Grid: Plot 1a",
       subtitle = "facet along columns") +
  facet_grid(~ age_category)

# Plot 2 = 1 variable to separate on, let the x-axis change based
# on the actual data
ggplot(data = midus, aes(x = BMI, y = life_satisfaction)) +
  geom_point(aes(color = age_category, shape = age_category)) + 
  labs(x = "Body Mass Index (BMI)", y = "Life Satisfaction",
       title = "Facet_Grid: Plot 1b",
       subtitle = "facet along columns, x-axes based on data") +
  facet_grid(~ age_category, scales = "free_x")

ggplot(data = midus, aes(x = BMI, y = life_satisfaction)) +
  geom_point(aes(color = age_category, shape = age_category)) + 
  labs(x = "Body Mass Index (BMI)", y = "Life Satisfaction",
       title = "Facet_Grid: Plot 1c",
       subtitle = "facet along rows") +
  facet_grid(age_category ~.)

```

Now let's see what happens when you facet based on 2 different factor variables. To do this, lets create a new categorical variable.

```{r factor, out.width=c('50%', '50%'), fig.show='hold'}
############################################################
##### But first, what happens when a categorical variable ##
##### is treated continuously, and not as a factor? ########
############################################################

# This creates a new variable called "session", and is scored as 1
# and 2. However, it will be treated as a numeric variable
session <- c(rep("1", times = 935), rep("2", times = 935))
midus["session"] <- rep(session, times = 2)
midus$session <- as.numeric(midus$session)

ggplot(data = midus, aes(x = hostility, y = life_satisfaction)) +
  geom_point(aes(color = session))

# If you are working with a categorical variable, it is 
# strongly recommended that you tell R to treat it as a factor.
# It is easier to keep categorical variables as words, rather than
# numeric codes. That is, rather than 1 and 2, let's instead
# use "session1" and "session2" for the new "session" variable. Let's recode
# this variable such that 1 = "session1" and 2 = "session2". Make sure
# R treats this as a "factor", rather than "character". You can
# always check using the "class()" function.
midus$session <- factor(midus$session, labels = c("session1", "session2"))
class(midus$session)

ggplot(data = midus, aes(x = hostility, y = life_satisfaction)) +
  geom_point(aes(color = session))

######################################
```

```{r fgrid2}
# Ok, back to faceting

# Plot 3 = 2 variables to separate on, age_category x wave
ggplot(data = midus, aes(x = hostility, y = life_satisfaction)) +
  geom_point(aes(color = age_category, shape = age_category)) + 
  labs(x = "Hostility", y = "Life Satisfaction",
       title = "Facet_Grid: Plot 3") +
  facet_grid(session ~ age_category)

# Plot 4 = 2 variables to separate on, species x time
ggplot(data = midus, aes(x = hostility, y = life_satisfaction)) +
  geom_point(aes(color = age_category, shape = age_category)) + 
  labs(x = "Hostility", y = "Life Satisfaction",
       title = "Facet_Grid: Plot 4") +
  facet_grid(age_category ~ session)
```

#### `facet_wrap`
This basically creates a ribbon that will just continue on to the next row when ready. This is useful for when you have categorical variables, but they don't necessarily need to be in a grid or matrix format. For instance, if one of the `facet_grid` cells would be empty, you probably don't want to show an empty plot (a plot with no points/shapes -- you'd rather it be just blank space). This does *not* follow the rows by columns syntax -- it will always just go to the next row.

```{r fwrap}
# Plot 1 = 1 variable to separate on, use default rows/columns
ggplot(data = midus, aes(x = hostility, y = life_satisfaction)) +
  geom_point(aes(color = age_category, shape = age_category)) + 
  labs(x = "Life Satisfaction", y = "Hostility",
       title = "Facet_Wrap: Plot 1") +
  facet_wrap(~ age_category)

# Plot 2 = 1 variable to separate on, change number of 
# columns of plots
ggplot(data = midus, aes(x = hostility, y = life_satisfaction)) +
  geom_point(aes(color = age_category, shape = age_category)) + 
  labs(x = "Life Satisfaction", y = "Hostility",
       title = "Facet_Wrap: Plot 1") +
  facet_wrap(~ age_category, ncol = 1)

# Plot 3 = 2 variables to separate on
ggplot(data = midus, aes(x = hostility, y = life_satisfaction)) +
  geom_point(aes(color = age_category, shape = age_category)) + 
  labs(x = "Life Satisfaction", y = "Hostility",
       title = "Facet_Wrap: Plot 1") +
  facet_wrap(~ age_category + session, ncol = 4)

```

#### Exercise 4: Faceting
**Exercise 4a:** Imagine each of the 3740 `midus` observations were randomly assigned to belong to one of two groups. Add to the code below to facet based on `session` (from above) and this new `group` variable. The result should include 4 subplots. Organize them such that they are in a 2x2 layout, with `group 1` in the left column, `group 2` in the right column, `session1` in the first row, and `session2` in the second row. 

```{r exercise 4a}

# midus$group <- sample(x = c("group1", "group2"), size = 3740,
#                   replace = TRUE)
# midus$group <- factor(midus$group)
# 
# ggplot(data = midus, aes(x = hostility, y = life_satisfaction)) +
#   geom_point(aes(color = age_category)) +
```

**Exercise 4b:** Now, use `facet_wrap` to get subplots reflecting all 3 factor variables (`age_category`, `group`, and `session`). How many subplots should you wind up with? Organize them such that there are 3 columns. 

```{r exercise 4b}

# ggplot(data = midus, aes(x = hostility, y = life_satisfaction)) +
#   geom_point(aes(color = age_category)) +
  
```

## Arranging Multiple Plots
Let's say you have 3 different, independent plots (not subplots) that you want to arrange in to a cohesive figure. You're arranging a grid of plots. There are 2 ways of doing this. The newer way is with a package called `ggpubr` and the function is `ggarrange()`. The older way is with the `gridExtra` package. Both will work, but for now, let's use the newer method. 

Importantly, you need to STORE these plots to your environment first (which means it won't immediately appear when you run the code). Then you can arrange the plots based on the name you assigned it.

```{r arrangingPlots, message=FALSE}
library(ggpubr)

# First, create your plots! If you want to have a single legend for every plot (ex: the colors are the same for all plots), then make sure your plots are coded accordingly. Then, ggarrange

# plot A - scatter plot
plotA <- ggplot(data = midus, aes(x = hostility, y = life_satisfaction)) +
  geom_point(aes(color = age_category)) +
  theme_minimal() +
  labs(title = "Scatter Plot")

# plot B - histogram
plotB <- ggplot(data = midus, aes(x = life_satisfaction)) +
  geom_histogram(binwidth = .1, aes(fill = age_category), alpha = .7) +
  theme_minimal() +
  labs(title = "Histogram")

# plot C - violin plot
plotC <- ggplot(data = midus, aes(x = age_category, y = life_satisfaction)) +
  geom_violin(aes(fill = age_category)) +
  theme_minimal() +
  labs(title = "Violin Plot")

ggarrange(plotA, plotB, plotC, nrow = 2, ncol = 2, 
          common.legend = TRUE, 
          labels = c("A", "B", "C"), legend = "bottom")
```

```{r arrangingPlots2, out.width=c('50%', '50%'), fig.show='hold'}
############################################################
##### This is fine, but it's kind of smushed. What you'd ###
##### actually want to see is the bottom violin plot taking#
##### up the entire 2 columns! This would be even better if#
##### the violin plot had the distributions stacked ########
##### vertically, rather than horizontally. Let's do it! ###
############################################################

# To change the violin plot, all we need to do is flip the coordinates

plotCNew <- ggplot(data = midus, aes(x = age_category, y = life_satisfaction)) +
  geom_violin(aes(fill = age_category)) +
  theme_minimal() +
  labs(title = "Violin Plot") +
  coord_flip()

# Let's look!
plotC
plotCNew
```

```{r arrangingPlots3}

# OK, looks great. Now what we're going to do is nest 2 ggarrange
# objects together. The first (inner most) object will combine 
# plots A and B into 1 plot. Then, we will add our new plotCNew.
# The idea is that there are 2 columns for A & B, but only 1 
# column for C. This means C has room to take up the full width.

ggarrange(ggarrange(plotA, plotB, ncol = 2, labels = c("A", "B"),
                    legend = "none"),
          plotCNew, nrow = 2, common.legend = TRUE,
          legend = "bottom", labels = c("", "C"))

# Final note about ggarrange: It does not like when ncol or nrow = 1. If you
# want a plot with 1 column and 3 rows, do *NOT* specify ncol = 1. Instead
# use nrow = 3. 

```

## Adding Lines & Text

Horizontal & Vertical Lines

```{r horizVert}

ggplot(data = midus, aes(x = BMI, y = self_esteem)) +
  geom_point(aes(color = age_category)) + 
  geom_vline(xintercept = mean(midus$BMI), color = "red") +
  labs(x = "Body Mass Index (BMI)", y = "Self-Esteem",
       title = "Vertical Mean Lines for BMI")

############################################################
##### What if you want it by each group? Need to create ####
##### that data, store it in an object, and then call it ###
##### from within the plot. Look at all these LAYERS! ######
############################################################

meansLength <- midus %>%
  group_by(age_category) %>%
  summarize(xint = mean(life_satisfaction))

ggplot(data = midus, aes(x = life_satisfaction, y = self_esteem)) +
  geom_point(aes(color = age_category), alpha = .3) +
  geom_vline(data = meansLength, aes(xintercept = meansLength$xint,
                                 color = meansLength$age_category,
                                 linetype = meansLength$age_category),
             size = 1.5) +
  labs(x = "Life Satisfaction", y = "Self Esteem",
       title = "Vertical Mean Lines for Life Satisfaction, by Age") +
  theme_classic() +
  scale_color_brewer(palette = "Dark2")
```

#### Exercise 5: Horizontal Lines
We just added vertical lines to represent the mean of `life_satisfaction` per `age_category`. Change the code below to represent the mean of `self_esteem` per `age_category`. Plot these means as horizontal lines. *HINT: You do not need to change the `meansWidth` code, only the plotting code*. BONUS: How can you get rid of the legend that shows the linetype? 

```{r exercise5}

# meansWidth <- midus %>%
#   group_by(age_category) %>%
#   summarize(yint = mean(self_esteem))
# 
# ggplot(data = midus, aes(x = BMI, y = self_esteem)) +
#   geom_point(aes(color = age_category)) +
#   labs(x = "BMI", y = "Self Esteem",
#        title = "Horizontal Mean Lines for Self-Esteem, by Age") 

```

For simple linear regression, you only need to add `geom_smooth`

```{r reg1, out.width=c('50%', '50%'), fig.show='hold'}
ggplot(data = midus, aes(x = hostility, y = self_esteem)) +
  geom_point() +
  geom_smooth(method = "lm") +
  theme_classic() +
  labs(title = "Regression Plot 1a", subtitle = "Simple Linear",
       x = "Hostility", y = "Self Esteem")

ggplot(data = midus, aes(x = hostility, y = self_esteem)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  theme_classic() +
  labs(title = "Regression Plot 1b", subtitle = "Simple Linear",
       x = "Hostility", y = "Self Esteem")

# Note: If you want a line that is not vertical/horizontal,
# use geom_abline. You'll need an intercept and slope. Usually,
# we're talking about regression lines, and geom_smooth is easier.
```

For plotting complex interactions from mulitple regressions, check out the `ggpredict()` function from the `ggeffects` package!  

If you want to annotate a plot with text, you can add an `annotate` layer.

```{r annotate}
# Nerdy Stats Warning!
# Simple linear regression coefficient of 2 standardized variables = correlation

corSelfEsteemLifeSat <- round(cor(scale(midus$self_esteem),
                                  scale(midus$life_satisfaction)),
                              digits = 2)

ggplot(data = midus, aes(x = scale(midus$self_esteem),
                         y = scale(midus$life_satisfaction))) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  theme_classic() +
  annotate(geom = "text", x = 1, y = -5,
           label = paste0("r = ", corSelfEsteemLifeSat)) +
  xlim(c(-4,3)) +
  ylim(c(-6,3)) +
  labs(title = "Annotating Plots",
       x = "Self Esteem",
       y = "Life Satisfaction")

# BONUS CHALLENGE: How could you check that the regression coefficient of the
# standardized variables is the same as the correlation of the original variables?
```

## Layers on Layers on Layers

#### Bar Plots and Error Bars

Thus far, we have not seen many bar plots (besides simple counts) or error bars. Usually, bar plots reflect the mean of a group. Just like we did with the vertical/horizontal lines, we'll want to transform our raw data into summary statistics. If you decide to work with summary stats, it is suggested that you create your summarized dataset outside of `ggplot` first, then call that from inside the `ggplot` function. It also means you can easily make your error bars.

```{r, errorBars, warning=FALSE}

# first, let's summarize the raw data
# and create a new data.frame with summary statistics
# This type of code comes from "tidyverse". As you get more familiar with R,
# we recommend checking this out!

summaryStats <- midus %>%
  group_by(age_category, sex) %>%
  summarize(means = mean(physical_health_self),
            sds = sd(physical_health_self)) %>%
  mutate(sdLower = means - sds) %>%
  mutate(sdUpper = means + sds)

# now, let's plot!  

ggplot(data = summaryStats, aes(x = age_category,
                                y = means,
                                fill = sex)) +
  geom_col(position = position_dodge(width=.9)) +
  geom_errorbar(aes(ymin = sdLower, ymax = sdUpper),
                position = position_dodge(width=.9),
                width = .2) +
  theme_classic() +
  scale_fill_brewer(palette = "Accent",
                    labels = c("mulheres", "homens")) +
  labs(title = "Error Bars",
       x = "",
       y = "Mean of Physical Health\n(self-reported)",
       fill = "Gender") 

```

#### Exercise 6: Bar Plots and Error Bars
Make a bar plot where the x-axis is `sex`, and contains bars for each of the 3 `age_category` categories. The legend should reflect that each `age_category` is a different color. Add error bars reflecting standard deviation.

```{r exercise6}

# ggplot(data = summaryStats, aes(x = , y = ,
#                                 fill = )) +
#   geom_col(position = position_dodge(width = .9)) +

```

#### Plotting Multiple Geoms
By now you've hopefully realized that you can add as many layers as you'd like to your `ggplot`. This means you can use multiple shapes or `geom_`s from the same data on the same plot. Let's look at line graphs and violin plots, as examples

```{r linegraphs}
############################################################
##### Like the bar graph above, let's say you want to know #
##### how the mean of physical health changes per category #
##### and per sex. A line connecting points might helpful! #
############################################################

ggplot(data = summaryStats, aes(x = age_category, y = means,
                                group = sex)) +
  geom_point(aes(color = sex, shape = sex), size = 3) +
  geom_errorbar(aes(ymin = sdLower, ymax = sdUpper,
                    color = sex), width = .1,
                linetype = "dashed") +
  ylim(c(0,6)) +
  geom_line(aes(color = sex)) +
  labs(y = "Mean Physical Health",
       x = "",
       color = "",
       title = "Line Graph") +
  scale_shape_discrete(guide = FALSE)
```

#### Exercise 7: Interpretation
What would you conclude from the above plot? What statistical test could you run to formally test this? In the empty chunk  below, run this test!
  
```{r exercise7}


```

What if you wanted to look at individual points in your dataset that are overlayed onto something else? Like overlaying the distribution of scores on top of a violin plot. 

```{r viol2, out.width=c('50%', '50%'), fig.show='hold'}
############################################################
##### A lot of these points overlap. Even if we change the #
##### transparency, it's still going to be difficult to ####
##### view all the points. To fix, this let's add a jitter.#
##### Jitter = slight irregularity, variance, unsteadiness.#
##### Think uneasy or nervous -- kinda shaky. We can jitter#
##### the points on the x-axis to randomly shift them ######
##### slightly. You can set how big you want the jitter to #
##### be using `width`. ####################################
############################################################

ggplot(data = midus, aes(x = hostility,
                         y = self_esteem)) +
  geom_point(aes(color = age_category)) +
  theme_classic() +
  scale_color_brewer(palette = "Set2") +
  labs(x = "Hostility",
       y = "Self Esteem",
       title = "What Is This Graph?",
       subtitle = "seriously, it's so bad")

ggplot(data = midus, aes(x = hostility,
                         y = self_esteem)) +
  geom_jitter(aes(color = age_category), width = 1) +
  theme_classic() +
  scale_color_brewer(palette = "Set2") +
  labs(x = "Hostility",
       y = "Self Esteem",
       title = "Jitter")
```

```{r viol3, out.width=c('50%', '50%'), fig.show='hold'}
# Now, violin plots show distributions. But using the code from above
# we can superimpose the individual points onto the violin plot. 
# In order to make this readable, let's change the transparency of
# all the violins to be very light. LAYERS!

ggplot(data = iris, aes(x = Species, y = Sepal.Length)) +
  geom_violin(aes(fill = Species), alpha = .3) +
  geom_point(aes(color = Species),
             position = position_jitter(width = .1)) +
  labs(x = "", y = "Length (cm)",
       title = "Distributions of Sepal Length",
       subtitle = "Per Iris Species") +
  theme_classic()

# Wanna add a boxlplot for good measure? Add another layer!
ggplot(data = iris, aes(x = Species, y = Sepal.Length)) +
  geom_violin(aes(fill = Species), alpha = .3) +
  geom_point(aes(color = Species),
             position = position_jitter(width = .1)) +
  geom_boxplot(aes(fill = Species), alpha = .3) +
  labs(x = "", y = "Length (cm)",
       title = "Distributions of Sepal Length",
       subtitle = "Per Iris Species") +
  theme_classic()

# Violin + Boxplot Only
ggplot(data = iris, aes(x = Species, y = Sepal.Length)) +
  geom_violin(aes(fill = Species), alpha = .3) +
  geom_boxplot(aes(color = Species), fill = "white", width = .1) +
  labs(x = "", y = "Length (cm)",
       title = "Distributions of Sepal Length",
       subtitle = "Per Iris Species") +
  theme_classic()

# Violin + Points in a different combination
ggplot(data = iris, aes(x = Species, y = Sepal.Length)) +
  geom_violin(aes(color = Species), fill = "white") +
  geom_point(aes(color = Species),
             position = position_jitter(width = .1)) +
  labs(x = "", y = "Length (cm)",
       title = "Distributions of Sepal Length",
       subtitle = "Per Iris Species") +
  theme_classic()
```

## Last Remaining Thoughts

#### Adding on to a plot

Thus far, every plot has been defined in its entirety. This is to reinforce everything that we've learned! However, you may run across help pages that store plots as objects, and then add to them. You should do what you find to be the most readable. I (Shelly) personally find this method to be hard to follow once the plotting gets complex. You may like it more.

```{r adding}

p <- ggplot(data = iris)
p <- p + geom_point(aes(x = Sepal.Length, y = Sepal.Width, color = Species))
p

```

#### Exporting your plots

What's the point of making all these publication-ready plots if you can't get them out of R? You can use the function `ggsave()`. This should work most of the time, however if the journal requires something more specific, try the second method below (it gives finer control).

**Important: You must consider your working directory!** Your computer is basically a series of folders. Folders are also known as "directories". Your "working directory" is where R is going to both look for files (like when reading in datasets) and where it will *save* (this is true of any file type: plots, .csv, .txt, etc.).

```{r saving}
############################################################
##### It's 2019! SAVE YOUR FILES TO BOX/DROPBOX/GITHUB #####
############################################################

# Method 1: ggsave
ggsave(filename = "plotSaveTest.png",
       width = 4, height = 4, units = "in")

# Method 2: Graphic Device. You first call the device, then plot, then
# turn device off. 

tiff(filename = "plotSave2.tiff", width = 7, height = 7, units = "in",
     res = 300, compression = "lzw") # Turn on device

ggplot(data = iris, aes(x = Species, y = Sepal.Length)) + # Now plot
  geom_point(aes(color = Species)) +
  labs(x = "", y = "Length")

dev.off() # Turn off device

```

#### When things go wrong

If your code isn't working, and you really think that it should, you might be using a function that comes from a different package. For example, the `psych` package also has a function called `alpha`. If this gives you trouble, just specify the package. EX: `ggplot2::alpha`.

If you want to cry because your plot still isn't giving you what you want, try storing your plot as an object, and then look at its inner workings. Let's look at a plot with multiple layers for example.

```{r plotbuild}

plotObject <- ggplot(data = iris,
                     aes(x = Species, y = Sepal.Length)) +
  geom_violin(aes(fill = Species), alpha = .3) +
  geom_point(aes(color = Species),
             position = position_jitter(width = .1)) +
  labs(x = "", y = "Length (cm)",
       title = "Distributions of Sepal Length",
       subtitle = "Per Iris Species") +
  theme_classic()

ggplot_build(plotObject)

```

Finally, when looking around the internet for help, make sure that the version number is kind of close to the one you're working with. The tidyverse has been around for some time now, and `ggplot2` has gone through many iterations over the years.

# The End!
You made it to the end! To celebrate, check out the new `pupR` package that allows you to look at adorable pictures of dogs in RStudio! [Here's](https://twitter.com/mathematicalm3l/status/1090720774464421889) a demo of how it works.  

Also, for those of you who get bored and want to not work, here's a fun xkcd plot we made! Just as a warning - the font import takes some time to complete.
```{r xkcd}
#to be honest, setting up the xkcd package was more annoying than I
# thought it would be, but after messing with it for ~20mins it worked!
#install.packages("xkcd")
#install.packages("extrafont")
library(xkcd)
library(extrafont)
download.file("http://simonsoftware.se/other/xkcd.ttf", dest="xkcd.ttf", mode="wb")
font_import()
loadfonts()

set.seed(1234) #this makes sure the random numbers generated will be the same

df <- data.frame(vacc = rnorm(50, sd = .75), #make fake data
                 autism = rnorm(50, sd = .55))


xrange <- c(-2,2) # specific for xkcd
yrange <- c(-2,2) # specific for xkcd

ratioxy <- diff(xrange) / diff(yrange) # specific for xkcd

mapping <- aes(x,  y,    # specific for xkcd
               scale,
               ratioxy,
               angleofspine ,
               anglerighthumerus,
               anglelefthumerus,
               anglerightradius,
               angleleftradius,
               anglerightleg,
               angleleftleg,
               angleofneck)

dataman <- data.frame(x= 1.75, y=-.4,   # specific for xkcd
                      scale = .5,
                      ratioxy = 1,
                      angleofspine =  -pi/2  ,
                      anglerighthumerus = c((7*pi)/4),
                      anglelefthumerus = c((5*pi)/4), # use the charts!!
                      anglerightradius = c(pi/6),
                      angleleftradius = c((5*pi)/6),
                      angleleftleg = 3*pi/2  + pi / 12 ,
                      anglerightleg = 3*pi/2  - pi / 12,
                      angleofneck = runif(1, 3*pi/2-pi/10, 3*pi/2+pi/10))

# finally, something you know -- ggplot!

ggplot(df, aes(x = vacc, y = autism, group = 1)) +
  geom_point() +
  geom_smooth(color = "red", method = "lm", se = FALSE) +
  xkcdaxis(xrange, yrange) +
  xkcdman(mapping, dataman) +
  annotate("text", x=0, y = -1.75,
           label = "The relationship between vaccines
           and autism is as flat as the earth",
           family="Arial", size = 3) +
  labs(y = "Autism",
       x = "Vaccines",
       title = "Which conspiracy theory\nshould you believe??") +
  theme_xkcd() +
  theme(text = element_text(family = "Arial", size = 11))

```

